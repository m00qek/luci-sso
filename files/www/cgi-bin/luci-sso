#!/usr/bin/ucode
import * as uci from 'uci';
import * as fs from 'fs';
import * as uclient from 'uclient';
import * as ubus from 'ubus';
import * as lucihttp from 'lucihttp';
import * as router from 'luci_sso.router';
import * as config_loader from 'luci_sso.config';

// 1. Constants & Configuration
const MAX_RESPONSE_SIZE = 65536; // 64 KB
const MAX_ENV_SIZE = 16384;      // 16 KB

/**
 * Safely reads a response body up to a hard limit.
 */
function safe_read_body(res) {
	if (!res || !res.body || type(res.body.read) != "function") return res;
	let data = res.body.read(MAX_RESPONSE_SIZE + 1);
	if (length(data) > MAX_RESPONSE_SIZE) return { error: "RESPONSE_TOO_LARGE" };
	res.body = data;
	return res;
}

/**
 * Safely retrieves an environment variable with length enforcement.
 */
function safe_getenv(key) {
	let val = getenv(key);
	if (val && length(val) > MAX_ENV_SIZE) return null;
	return val;
}

// 2. Imperative Shell: Define the real I/O provider
let _ubus_conn = null;

const io = {
	time: time,
	read_file: (path) => fs.readfile(path),
	write_file: (path, data) => fs.writefile(path, data),
	rename: (old, new) => fs.rename(old, new),
	http_get: (url) => {
		let conn = uclient.connect(url);
		if (!conn) return { error: "CONNECT_FAILED" };
		let res = safe_read_body(conn.request("GET"));
		conn.disconnect();
		return res;
	},
	http_post: (url, opts) => {
		let conn = uclient.connect(url);
		if (!conn) return { error: "CONNECT_FAILED" };
		if (opts.headers) {
			for (let k, v in opts.headers) conn.header(k, v);
		}
		let res = safe_read_body(conn.request("POST", opts.body));
		conn.disconnect();
		return res;
	},
	urlencode: lucihttp.urlencode,
	getenv: safe_getenv,
	log: (level, msg) => { warn(`[luci-sso] [${level}] ${msg}\n`); },
	
	/**
	 * Makes a UBUS call.
	 */
	ubus_call: (obj, method, args) => {
		if (!_ubus_conn) {
			_ubus_conn = ubus.connect();
			if (!_ubus_conn) return null;
		}
		return _ubus_conn.call(obj, method, args);
	}
};

// 3. Global Error Helper
function cgi_die(msg, status) {
	io.log("crit", msg);
	print(`Status: ${status || 500}\n`);
	print(`Content-Type: text/plain\n\n`);
	print(`${msg}\n`);
	exit(1);
}

// 4. Load Configuration (UCI)
const cursor = uci.cursor();
const conf_res = config_loader.load(cursor, io);

if (!conf_res.ok) {
	if (conf_res.error === "DISABLED") {
		cgi_die("SSO is disabled", 403);
	}
	cgi_die(`Configuration Error: ${conf_res.error} ${conf_res.details || ""}`, 500);
}
const config = conf_res.data;

// 5. Build Request Object
const request = {
	path: io.getenv("PATH_INFO") || "/",
	query_string: io.getenv("QUERY_STRING"),
	http_cookie: io.getenv("HTTP_COOKIE")
};

// 6. Functional Core: Delegate to Router
const res = router.handle(io, config, request);

// 7. Output Result
print(`Status: ${res.status}\n`);
for (let header in res.headers) {
	print(`${header}\n`);
}
print("\n");
print(res.body);
