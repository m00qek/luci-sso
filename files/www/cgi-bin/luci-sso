#!/usr/bin/ucode
import * as uci from 'uci';
import * as fs from 'fs';
import * as ubus from 'ubus';
import * as lucihttp from 'lucihttp';
import * as router from 'luci_sso.router';
import * as config_loader from 'luci_sso.config';

/**
 * HTTP helper using uclient-fetch binary.
 */
function fetch_http(method, url, opts, io) {
	let out_path = '/tmp/uclient.out';
	let err_path = '/tmp/uclient.err';
	let cmd = ['uclient-fetch', '-O', out_path, '--timeout=10'];
	
	if (opts?.headers) {
		for (let k, v in opts.headers) {
			push(cmd, `--header=${k}: ${v}`);
		}
	}

	if (method === 'POST' && opts?.body) {
		push(cmd, `--post-data=${opts.body}`);
	}

	// SSL Trust for Development
	if (io?.idp_cert && index(url, 'https://') == 0) {
		push(cmd, `--ca-certificate=${io.idp_cert}`);
	}

	push(cmd, url);

	let full_cmd = join(' ', map(cmd, (c) => `"${replace(c, /"/g, '\\"')}"`)) + ` 2>${err_path}`;
	let res = system(full_cmd);

	let body = fs.readfile(out_path);
	let err = fs.readfile(err_path);
	fs.unlink(out_path);
	fs.unlink(err_path);

	if (res !== 0) {
		io.log("error", "HTTP FETCH FAILED: " + err);
		return { error: "FETCH_FAILED", details: err };
	}

	return {
		status: 200,
		body: trim(body || "")
	};
}

const io = {
	time: time,
	read_file: (path) => fs.readfile(path),
	write_file: (path, data) => fs.writefile(path, data),
	rename: (old, new) => fs.rename(old, new),
	log: (level, msg) => { warn(`[luci-sso] [${level}] ${msg}\n`); },
	http_get: function(url) { return fetch_http('GET', url, null, this); },
	http_post: function(url, opts) { return fetch_http('POST', url, opts, this); },
	urlencode: lucihttp.urlencode,
	getenv: getenv,
	ubus_call: (obj, method, args) => {
		let conn = ubus.connect();
		if (!conn) return null;
		let res = conn.call(obj, method, args);
		return res;
	},
	// Dev Cert Path (Trust the common Root CA)
	idp_cert: "/etc/luci-sso/certs/rootCA.crt"
};

const cursor = uci.cursor();
const config = config_loader.load(cursor, io);

const request = {
	path: getenv("PATH_INFO") || "/",
	query_string: getenv("QUERY_STRING"),
	http_cookie: getenv("HTTP_COOKIE")
};

try {
    if (!config.ok) {
        die("Config Error: " + config.error + (config.details ? " (" + config.details + ")" : ""));
    }

    const res = router.handle(io, config.data, request);

    if (res.status == 302) {
        let loc = "";
        for (let i, h in res.headers) {
            if (index(h, "Location:") == 0) loc = trim(substr(h, 10));
        }
        
        fs.stdout.write("Status: 302 Found\n");
        for (let i, h in res.headers) fs.stdout.write(h + "\n");
        fs.stdout.write("Content-Type: text/html\n\n");
        fs.stdout.write('<html><head><script>window.location.href="' + loc + '";</script></head>');
        fs.stdout.write('<body><p>Redirecting to <a href="' + loc + '">' + loc + '</a>...</p></body></html>\n');
    } else {
        if (res.status != 200) fs.stdout.write("Status: " + res.status + "\n");
        for (let i, h in res.headers) fs.stdout.write(h + "\n");
        fs.stdout.write("\n");
        fs.stdout.write(res.body || "");
    }
} catch (e) {
    warn("[luci-sso] Router crash: " + e + "\n");
    fs.stdout.write("Status: 500 Internal Server Error\nContent-Type: text/plain\n\nError: " + e + "\n");
}

sleep(0.1);