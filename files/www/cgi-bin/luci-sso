#!/usr/bin/ucode
import * as uci from 'uci';
import * as fs from 'fs';
import * as uclient from 'uclient';
import * as ubus from 'ubus';
import * as lucihttp from 'lucihttp';
import * as router from 'luci_sso.router';
import * as config_loader from 'luci_sso.config';
import * as https from 'luci_sso.https';

// 1. Constants & Configuration
const MAX_ENV_SIZE = 16384;      // 16 KB

/**
 * Safely retrieves an environment variable with length enforcement.
 */
function safe_getenv(key) {
	let val = getenv(key);
	if (val && length(val) > MAX_ENV_SIZE) return null;
	return val;
}

// 2. Imperative Shell: Define the real I/O provider
let _ubus_conn = null;

const io = {
	time: time,
	read_file: function(path) { return fs.readfile(path); },
	write_file: function(path, data) { return fs.writefile(path, data); },
	rename: function(old, new) { return fs.rename(old, new); },
	
	log: function(level, msg) { warn(`[luci-sso] [${level}] ${msg}\n`); },

	http_get: function(url) {
		let res = https.request('GET', url, { timeout: 10000 });
        if (res.error) {
            this.log("error", `HTTPS GET failed for ${url}: ${res.error}`);
            return { error: "NETWORK_ERROR" };
        }
        return { status: res.status, body: res.body };
	},

	http_post: function(url, opts) {
		let res = https.request('POST', url, { 
            timeout: 10000, 
            headers: opts?.headers || {},
            post_data: opts?.body 
        });
        if (res.error) {
            this.log("error", `HTTPS POST failed for ${url}: ${res.error}`);
            return { error: "NETWORK_ERROR" };
        }
        return { status: res.status, body: res.body };
	},

	urlencode: lucihttp.urlencode,
	getenv: safe_getenv,
	
	ubus_call: function(obj, method, args) {
		if (!_ubus_conn) {
			_ubus_conn = ubus.connect();
			if (!_ubus_conn) return null;
		}
		return _ubus_conn.call(obj, method, args);
	}
};

const cursor = uci.cursor();
const config = config_loader.load(cursor, io);

const request = {
	path: getenv("PATH_INFO") || "/",
	query_string: getenv("QUERY_STRING"),
	http_cookie: getenv("HTTP_COOKIE")
};

try {
    if (!config.ok) {
        die("Config Error: " + config.error + (config.details ? " (" + config.details + ")" : ""));
    }

    const res = router.handle(io, config.data, request);
    let output = "";

    if (res.status == 302) {
        let loc = "";
        for (let i, h in res.headers) {
            if (index(h, "Location:") == 0) loc = trim(substr(h, 10));
        }
        
        output += "Status: 302 Found\n";
        for (let i, h in res.headers) output += h + "\n";
        output += "Content-Type: text/html\n\n";
        output += '<html><head><script>window.location.href="' + loc + '";</script></head>';
        output += '<body><p>Redirecting to <a href="' + loc + '">' + loc + '</a>...</p></body></html>\n';
    } else {
        if (res.status != 200) output += "Status: " + res.status + "\n";
        for (let i, h in res.headers) output += h + "\n";
        output += "\n";
        output += (res.body || "");
    }

    fs.stdout.write(output);
} catch (e) {
    warn("[luci-sso] Router crash: " + e + "\n" + e.stacktrace + "\n");
    fs.stdout.write("Status: 500 Internal Server Error\nContent-Type: text/plain\n\nRouter Crash\n");
}

sleep(0.1);
